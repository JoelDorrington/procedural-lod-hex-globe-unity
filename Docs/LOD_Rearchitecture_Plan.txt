LOD Re-Architecture Plan
=========================

Goal
----
Design a four-tier LOD system for the planet terrain with an "Extreme" highest fidelity layer that is the ground-truth geometry, from which progressively coarser (High, Medium, Low) representations are derived. The Extreme layer is streamed in small visible regions only (camera-dependent) to maintain high FPS. A loading phase (with progress bar) precomputes / bakes data required for fast runtime selection and morphing.

LOD Levels
----------
1. Low     : Whole planet always resident (very low resolution). Used for far camera & initial placeholder while higher LODs stream.
2. Medium  : Whole planet always resident. Captures large continental shapes & major ridges.
3. High    : Whole planet always resident OR segmented (depending on memory). Adds secondary ridge & coastline fidelity.
4. Extreme : NOT fully resident. Highest resolution patches (streamed quadtree / clipmap style) near the camera only. Contains fractal displacement + fine coastline details (procedurally evaluated or baked heightmap tiles).

Key Principles
--------------
- Single Source of Truth: Extreme level defines canonical height function (procedural). Lower LODs are derived via controlled downsampling/feature-preserving simplification so they are consistent (no popping discontinuities in aggregate height).
- Deterministic Sampling: All levels use the same underlying procedural height provider (MountainRange + high-frequency fractal) with a fixed seed. Pre-bake sampled heights into multi-resolution tile cache (mip pyramid) for rapid mesh builds.
- Streaming Extreme: Camera defines a spherical cap (or view-aligned frustum intersection) for required Extreme tiles. Use LRU cache for meshes; generate asynchronously (coroutines or Unity Job System / Burst in future).
- Seamless Transitions: Overlap one ring of Extreme tiles beyond view; cross-fade/morph between High and Extreme heights at tile edges (geomorph factor based on camera distance to tile center and tile LOD).
- Chunk Coordinate System: Use cube-face quadtree indexing (face, lodDepth, x, y). LOD level mapped to quadtree depth ranges: Low (depth 0), Medium (depth 2?), High (depth 4?), Extreme (depth >= 6 dynamic) – actual numbers configurable.

Up-Front Loading Phase
----------------------
Steps executed once at startup (with progress UI):
1. Enumerate required faces and quadtree depths for pre-baked levels (Low/Medium/High target depths).
2. For each tile (face, depth, x, y): Sample procedural height provider on a uniform grid, store into an in-memory height buffer.
3. Build meshes (vertex positions, normals) for Low/Medium/High levels and upload to GPU.
4. Build a hierarchical metadata structure: per-tile min/max height, average normal, variance (to support error metric & culling decisions).
5. Serialize optional caches (ScriptableObject asset or binary file) to skip future full recompute.

Runtime System
--------------
Managers:
- PlanetLodManager (new) orchestrates tile streaming, holds references to resident meshes for L/M/H, and manages Extreme tile cache.
- ExtremeTileStreamer: Decides which extreme tiles to load based on camera position + radius thresholds.
- HeightSampler / ProceduralHeightEvaluator: Provides synchronous sampling for bake; optional burst job path later.

Data Structures
---------------
Tile Descriptor:
struct TileId { int face; int depth; int x; int y; }
Per Tile Data:
- resolution (vertsPerEdge)
- vertex buffer (vector3[] or NativeArray<float3>)
- normal buffer (optional lazy compute)
- min/max height
- variance/error metric (RMS difference vs parent upsampled)
- children refs (for traversal)

LOD Selection
-------------
At runtime (excluding Extreme):
- For each visible face, traverse from Low level downward where screen-space error > threshold and tile within camera view frustum.
- Stop at High pre-baked mesh tile level (no deeper) for base surface.
Extreme Overlay:
- Determine camera ground-projected point (planet center to camera normalized) and define a radius (in radians / arc length) for extreme detail.
- Collect High tiles intersecting this area; refine to deeper (extreme) sub-tiles (depth >= extremeMinDepth) and queue generation if not cached.
- For regions still generating, continue showing High tile.

Extreme Tile Generation
-----------------------
1. When requested, sample procedural height at extreme resolution.
2. Optionally add GPU-only displacement (tessellation) — future extension.
3. Store height data & build mesh. Compute skirt or stitching strip to match parent high tile boundary (geomorph not mandatory if vertex alignment inherits sample positions exactly).
4. Insert into LRU cache; if memory pressure exceeds budget, evict farthest tiles (destroy meshes or return to pool).

Height Function Decomposition
-----------------------------
H_total(dir) = H_base(dir) + H_ridge(dir) + H_fractal(dir)
Pre-baked L/M/H store sampled H_simplified where high-frequency fractal above a cutoff frequency is filtered out (band-limited). At runtime, for High you can optionally add a cheaper medium frequency pass in vertex shader.
Extreme tiles evaluate full H_total including high-frequency fractal (several octaves). This ensures coastlines and mountain ridges are crisp only close to camera.

Filtering Strategy
------------------
During baking for L/M/H:
- Evaluate full height but apply octave weighting mask: for each fractal octave with frequency > f_threshold(level), attenuate (or exclude) to avoid aliasing.
- Optionally apply quadric error decimation after sampling for additional triangle reduction (future optimization).

Normals
-------
- Precompute normals per tile from height samples (central differences on sphere surface). Store for L/M/H.
- Extreme normals computed on demand.
- Consider storing tangent frame for advanced shading later.

Edge Stitching
--------------
- Ensure consistent sampling grid alignment: child tile samples exactly subdivide parent extents (no floating drift) => enables seamless borders.
- For transitions between High and Extreme: parent and child share boundary vertices (no cracks). If different frequencies included, either (a) clamp fractal to zero on border for child, or (b) add fractal to parent in a narrow blend band (simpler: option a initially).

Memory & Performance Targets
----------------------------
Assume baseRadius ~30, typical High resolution per face maybe 128x128 (16k verts) * 6 = ~96k verts (OK). Extreme tiles perhaps 128x128 each but only 4–8 loaded => < 1M verts worst case.

Loading Bar Breakdown
---------------------
- Phase 0: Gather tiles list.
- Phase 1: Sample Low (progress 0–0.15)
- Phase 2: Sample Medium (0.15–0.40)
- Phase 3: Sample High (0.40–0.80)
- Phase 4: Build meshes & normals (0.80–0.95)
- Phase 5: Finalize metadata + GC/pool warmup (0.95–1.0)

API / Class Sketch
------------------
PlanetLodManager : MonoBehaviour
  - public TerrainConfig config;
  - public Camera targetCamera;
  - List<LodFaceSet> residentLevels; // Low/Med/High
  - ExtremeTileStreamer streamer;
  - void Start() => StartCoroutine(BakeAll());
  - void Update() => { streamer.Update(); SelectVisibleTiles(); }

ExtremeTileStreamer
  - Queue<TileId> generationQueue
  - Dictionary<TileId, TileData> cache
  - Update(cameraPos) => determine needed; enqueue; manage LRU

HeightBakeJob (future: Burst)
  - Input: TileId + resolution + frequencyMask
  - Output: heights[]

Immediate Implementation Phases
--------------------------------
Phase 1 (Scaffold):
- Create new PlanetLodManager separate from TerrainRoot (leave old simple system intact for fallback).
- Implement TileId + TileData classes.
- Implement synchronous bake loop with progress callback (simple UI Text/Slider placeholder).
- Build Low/Medium/High meshes (no streaming yet). Display High only for now.

Phase 2 (Extreme Streaming):
- Add streaming selection logic & caching (synchronous generation for prototype).
- Seamless stitching via shared sample alignment (no skirts initially).

Phase 3 (Filtering / Frequency Partition):
- Split height provider into base + fractal detail. Provide frequency cutoff per LOD.
- Add fractal only in Extreme.

Phase 4 (Optimization):
- Convert sampling loops to Jobs/Burst.
- Add mesh pooling & asynchronous generation with coroutines.

Risks / Mitigations
-------------------
- Pop when swapping High<->Extreme: mitigate by shared boundaries and optional fade.
- Bake time too long: offer cancel / partial bake (only Low+Medium first) then progressive High.
- Memory spike during bake: stream output per tile instead of holding all raw samples simultaneously.

Metrics to Collect
------------------
- Bake duration per phase.
- Peak memory usage for tile buffers.
- Average generation time per Extreme tile runtime.

Next Steps (Coding Order)
-------------------------
1. Create PlanetLodManager + TileId/TileData.
2. Implement BakeAll coroutine with progress callbacks into a simple UI (PlanetLoadingUI).
3. Generate Low/Medium/High face meshes (single face sampling function that accepts depth & coordinate).
4. Display High set (toggle through levels for testing).
5. Add Extreme streaming region (fixed radius test) and generation queue.
6. Partition height provider (add HighFreqFractalHeightProvider wrapper) for frequency filtering.
7. Refine transitions & performance.

End of Plan.
