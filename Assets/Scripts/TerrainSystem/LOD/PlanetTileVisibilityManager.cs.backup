using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System;

namespace HexGlobeProject.TerrainSystem.LOD
{
    /// <summary>
    /// Google Maps-style tile explorer for the planet.
    /// - Zoom level (depth) determines the tile resolution.
    /// - A raycast heuristic samples the screen and spawns tiles for hit locations.
    /// - The heuristic runs at a target frequency and ensures tiles aren't duplicated or destroyed prematurely.
    /// </summary>
    [AddComponentMenu("HexGlobe/Planet Tile Explorer Cam")]
    public class PlanetTileVisibilityManager : MonoBehaviour
    {
        // Runtime diagnostic: count active manager instances to detect duplicate spawners
        private static int s_activeManagers = 0;

        // ----- Inspector / references -----
        [SerializeField]
        [Tooltip("Game Camera controller (must provide access to an actual Camera)")]
        public CameraController GameCamera;

        private Camera cam => GameCamera.GetComponent<Camera>();
        private float _sphereViewportRadius;

        [SerializeField]
        [Tooltip("Terrain config")]
        public TerrainConfig config;

        public TerrainConfig TerrainConfig => config;
        private float _planetRadius => config != null ? config.baseRadius : 1f;

        [SerializeField]
        [Tooltip("Optional transform representing the planet center (used for raycasts). If null, this GameObject's transform is used.")]
        private Transform planetTransform;

        private Vector3 _planetCenter;

        [SerializeField]
        [Tooltip("Fallback terrain material used when no manager is present")]
        private Material terrainMaterial;

        // ----- Tuning -----
        [SerializeField]
        [Tooltip("Maximum allowed depth (soft cap)")]
        private int maxDepth = 2;

        [SerializeField]
        [Tooltip("Bias exponent used when mapping camera distance to discrete depth bins. 1 = linear, >1 biases bins toward higher distances.")]
        private float binBias = 1.2f;

    // [SerializeField]
    // [Tooltip("Maximum camera distance (units) used when computing depth levels. Values larger than this clamp the mapping.")]
    // private int depthLevelMaxDistance = 50; // deprecated in favor of CameraController-driven mapping

        [SerializeField]
        [Tooltip("Approximate number of rays to cast; actual cast uses a square sampling grid <= this value")]
        private int _maxRays = 100;

        [SerializeField]
        [Tooltip("Layer mask for raycast collision detection. Use this to exclude terrain tile meshes to prevent occlusion.")]
        private LayerMask raycastLayerMask = -1; // Default to all layers

        // Runtime-used mask for actual physics raycasts
        private int effectiveRaycastMask = 1 << 0; // Default layer only

        [SerializeField]
        [Tooltip("Layer to assign to spawned terrain tile GameObjects. Should be excluded from raycastLayerMask to prevent self-occlusion.")]
        private int terrainTileLayer = 0; // Default layer

        [SerializeField]
        [Tooltip("Exponent for radial bias smoothing function. Higher values concentrate rays more toward sphere edges.")]
        private float radialBiasExponent = 2.0f;

        // Curved tile-slot icosphere settings
        [SerializeField]
        [Tooltip("Multiplier applied to the planet radius for the CURVED tile-slot icosphere.")]
        private float curvedIcosphereRadiusMultiplier = 1.01f;        // Discrete key for mesh cache to avoid floating-point/canonical timing issues
        private struct TileMeshKey
        {
            public int face, x, y, depth;
            public TileMeshKey(int face, int x, int y, int depth) { this.face = face; this.x = x; this.y = y; this.depth = depth; }
            public override bool Equals(object obj) => obj is TileMeshKey k && k.face == face && k.x == x && k.y == y && k.depth == depth;
            public override int GetHashCode() => ((face * 73856093) ^ (x * 19349663) ^ (y * 83492791) ^ (depth * 15485863));
        }

        private struct TileMeshCacheEntry { public Mesh mesh; public Vector3 centerWorld; }
        private readonly Dictionary<TileMeshKey, TileMeshCacheEntry> tileMeshCache = new Dictionary<TileMeshKey, TileMeshCacheEntry>();

        // Precomputed tile-center normals for the current depth to speed up mapping
        public struct PrecomputedTileEntry
        {
            public Vector3 normal; // canonical center normal (unit)
            public int face;
            public int x;
            public int y;
            // Barycentric center within face (0..1)
            public float uCenter;
            public float vCenter;
            // World-space center position (planet center + direction * curved radius)
            public Vector3 centerWorld;
            // World-space corner positions (triangle corners p0,p1,p2)
            public Vector3[] cornerWorldPositions;
            // tiles per edge for this depth
            public int tilesPerEdge;
            // tile origin offsets in global barycentric coordinates (u0,v0)
            public float tileOffsetU;
            public float tileOffsetV;
        }
        // Build a list of canonical tile-center normals for the given depth.
        // This is called when depth changes to accelerate per-ray mapping.
        public void PrecomputeTileNormalsForDepth(int depth)
        {
            // Ensure we use the current planet transform position in case the serialized
            // 'planetTransform' field was changed after Awake (tests set this via SerializedObject).
            _planetCenter = planetTransform != null ? planetTransform.position : this.transform.position;

            // Clear any existing precomputed data and colliders for previous depth
            _precomputedTilesForDepth.Clear();
            // No collider container - colliders are managed per-tile inside PlanetTerrainTile
            int tilesPerEdge = 1 << depth;

            if (depth == 0)
            {
                // Depth 0: force exactly one tile slot per icosphere face (20 total)
                float curvedMultiplier = Mathf.Clamp(curvedIcosphereRadiusMultiplier, 0.95f, 1.2f);
                for (int face = 0; face < 20; face++)
                {
                    int x = 0, y = 0;
                    // Compute tile center barycentric coordinates (center of single cell)
                    float u = (x + 0.5f) / tilesPerEdge;
                    float v = (y + 0.5f) / tilesPerEdge;
                    if (u + v > 1f)
                    {
                        float excess = (u + v) - 1f;
                        u -= excess * 0.5f;
                        v -= excess * 0.5f;
                    }

                    Vector3 dir = IcosphereMapping.BarycentricToWorldDirection(face, u, v).normalized;
                    var entry = new PrecomputedTileEntry
                    {
                        normal = dir,
                        face = face,
                        x = x,
                        y = y,
                        uCenter = u,
                        vCenter = v,
                        tilesPerEdge = tilesPerEdge,
                    };
                    // Compute sampled height at the canonical center using the configured height provider
                    float centerHeight = 0f;
                    if (config != null)
                    {
                        var provider = config.heightProvider ?? (TerrainHeightProviderBase)new SimplePerlinHeightProvider();
                        // Use the correct resolution for this tile (tilesPerEdge)
                        int sampleRes = tilesPerEdge > 0 ? tilesPerEdge : (config.baseResolution > 0 ? config.baseResolution : 16);
                        centerHeight = provider.Sample(in dir, sampleRes) * config.heightScale;
                    }
                    entry.centerWorld = entry.normal * (_planetRadius + centerHeight) * curvedMultiplier + _planetCenter;

                    float u0 = (float)x / tilesPerEdge;
                    float v0 = (float)y / tilesPerEdge;
                    float u1 = (float)(x + 1) / tilesPerEdge;
                    float v1 = v0;
                    float u2 = u0;
                    float v2 = (float)(y + 1) / tilesPerEdge;

                    entry.tileOffsetU = u0;
                    entry.tileOffsetV = v0;

                    entry.cornerWorldPositions = new Vector3[3];
                    entry.cornerWorldPositions[0] = IcosphereMapping.BarycentricToWorldDirection(face, u0, v0).normalized * (_planetRadius * curvedMultiplier) + _planetCenter;
                    entry.cornerWorldPositions[1] = IcosphereMapping.BarycentricToWorldDirection(face, u1, v1).normalized * (_planetRadius * curvedMultiplier) + _planetCenter;
                    entry.cornerWorldPositions[2] = IcosphereMapping.BarycentricToWorldDirection(face, u2, v2).normalized * (_planetRadius * curvedMultiplier) + _planetCenter;

                    _precomputedTilesForDepth.Add(entry);
                }
            }
            else
            {
                for (int face = 0; face < 20; face++)
                {
                    for (int x = 0; x < tilesPerEdge; x++)
                    {
                        for (int y = 0; y < tilesPerEdge; y++)
                        {
                            if (!IcosphereMapping.IsValidTileIndex(x, y, depth)) continue;

                            // Compute tile center barycentric coordinates using canonical method
                            IcosphereMapping.GetTileBarycentricCenter(x, y, depth, out float u, out float v);

                            Vector3 dir = IcosphereMapping.BarycentricToWorldDirection(face, u, v).normalized;
                            var entry = new PrecomputedTileEntry
                            {
                                normal = dir,
                                face = face,
                                x = x,
                                y = y,
                                uCenter = u,
                                vCenter = v,
                                tilesPerEdge = tilesPerEdge,
                            };
                            // compute center world position using sampled height and curved multiplier
                            float curvedMultiplier = Mathf.Clamp(curvedIcosphereRadiusMultiplier, 0.95f, 1.2f);
                            float centerHeight = 0f;
                            if (config != null)
                            {
                                var provider = config.heightProvider ?? (TerrainHeightProviderBase)new SimplePerlinHeightProvider();
                                int sampleRes = tilesPerEdge > 0 ? tilesPerEdge : (config.baseResolution > 0 ? config.baseResolution : 16);
                                centerHeight = provider.Sample(in dir, sampleRes) * config.heightScale;
                            }
                            entry.centerWorld = entry.normal * (_planetRadius + centerHeight) * curvedMultiplier + _planetCenter;


                            // compute triangle corner barycentric coords (standard triangle inside cell)
                            float u0 = (float)x / tilesPerEdge;
                            float v0 = (float)y / tilesPerEdge;
                            float u1 = (float)(x + 1) / tilesPerEdge;
                            float v1 = v0;
                            float u2 = u0;
                            float v2 = (float)(y + 1) / tilesPerEdge;

                            entry.tileOffsetU = u0;
                            entry.tileOffsetV = v0;

                            entry.cornerWorldPositions = new Vector3[3];
                            entry.cornerWorldPositions[0] = IcosphereMapping.BarycentricToWorldDirection(face, u0, v0).normalized * (_planetRadius * curvedMultiplier) + _planetCenter;
                            entry.cornerWorldPositions[1] = IcosphereMapping.BarycentricToWorldDirection(face, u1, v1).normalized * (_planetRadius * curvedMultiplier) + _planetCenter;
                            entry.cornerWorldPositions[2] = IcosphereMapping.BarycentricToWorldDirection(face, u2, v2).normalized * (_planetRadius * curvedMultiplier) + _planetCenter;

                            _precomputedTilesForDepth.Add(entry);
                        }
                    }
                }
            }

            // NOTE: Collider GameObjects and per-depth collider container were removed.
            // PlanetTerrainTile now manages its own MeshCollider. We still precompute the
            // canonical tile entries above, but do not allocate a shared container or collider meshes here.
            // removed debug logging for precompute in production

            // register into static registry for external lookup (by depth)
            s_precomputedRegistry[depth] = new List<PrecomputedTileEntry>(_precomputedTilesForDepth);
        }

    // ...existing code...

        // Find the precomputed tile entry whose normal is closest to the given direction
        private PrecomputedTileEntry GetClosestPrecomputedTile(Vector3 direction)
        {
            PrecomputedTileEntry best = default;
            float bestDot = -1f;
            Vector3 d = direction.normalized;
            for (int i = 0; i < _precomputedTilesForDepth.Count; i++)
            {
                var e = _precomputedTilesForDepth[i];
                float dot = Vector3.Dot(d, e.normal);
                if (dot > bestDot)
                {
                    bestDot = dot;
                    best = e;
                }
            }
            return best;
        }

    private List<PrecomputedTileEntry> _precomputedTilesForDepth = new List<PrecomputedTileEntry>();
    private int _lastPrecomputedDepth = -1;
    // Static registry so other systems can query tile corner positions by faceNormal+depth
    private static readonly Dictionary<int, List<PrecomputedTileEntry>> s_precomputedRegistry = new();

        /// <summary>
        /// Find the best precomputed tile entry for the given faceNormal and depth.
        /// Returns true if found and outputs the entry.
        /// </summary>
        public static bool GetPrecomputedEntry(Vector3 faceNormal, int depth, out PrecomputedTileEntry entryOut)
        {
            entryOut = default;
            if (!s_precomputedRegistry.TryGetValue(depth, out var list) || list == null || list.Count == 0) return false;
            float bestDot = -1f;
            Vector3 d = faceNormal.normalized;
            PrecomputedTileEntry best = default;
            foreach (var e in list)
            {
                float dot = Vector3.Dot(d, e.normal);
                if (dot > bestDot)
                {
                    bestDot = dot;
                    best = e;
                }
            }
            if (bestDot < 0f) return false;
            entryOut = best;
            return true;
        }

        /// <summary>
        /// Return the canonical 1-D index into the precomputed registry for the given TileId.
        /// Also returns the entry if found.
        /// </summary>
        public static bool GetPrecomputedIndex(TileId tileId, out int indexOut, out PrecomputedTileEntry entryOut)
        {
            indexOut = -1; entryOut = default;
            if (!s_precomputedRegistry.TryGetValue(tileId.depth, out var list) || list == null) return false;
            // Find the best match by nearest normal (same logic as GetPrecomputedEntry)
            float bestDot = -1f;
            int bestIdx = -1;
            Vector3 d = tileId.faceNormal.normalized;
            for (int i = 0; i < list.Count; i++)
            {
                var e = list[i];
                float dot = Vector3.Dot(d, e.normal);
                if (dot > bestDot)
                {
                    bestDot = dot;
                    bestIdx = i;
                }
            }
            if (bestIdx < 0) return false;
            indexOut = bestIdx;
            entryOut = list[bestIdx];
            return true;
        }

        /// <summary>
        /// Return the world-space corner positions for a tile identified by faceNormal and depth.
        /// If not found, returns false.
        /// </summary>
        public static bool TryGetTileCornerWorldPositions(Vector3 faceNormal, int depth, out Vector3[] corners)
        {
            corners = null;
            if (GetPrecomputedEntry(faceNormal, depth, out var e))
            {
                corners = e.cornerWorldPositions;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Overload: retrieve corner world positions using a TileId (faceNormal + depth).
        /// </summary>
        public static bool TryGetTileCornerWorldPositions(TileId tileId, out Vector3[] corners)
        {
            return TryGetTileCornerWorldPositions(tileId.faceNormal, tileId.depth, out corners);
        }

        /// <summary>
        /// Overload: retrieve the precomputed entry using a TileId (faceNormal + depth).
        /// </summary>
        public static bool GetPrecomputedEntry(TileId tileId, out PrecomputedTileEntry entryOut)
        {
            return GetPrecomputedEntry(tileId.faceNormal, tileId.depth, out entryOut);
        }

        /// <summary>
        /// Return the world-space center position for a tile identified by faceNormal and depth.
        /// Overload accepts TileId as well.
        /// </summary>
        public static bool TryGetTileCenterWorldPosition(Vector3 faceNormal, int depth, out Vector3 center)
        {
            center = Vector3.zero;
            if (GetPrecomputedEntry(faceNormal, depth, out var e))
            {
                center = e.centerWorld;
                return true;
            }
            return false;
        }

        public static bool TryGetTileCenterWorldPosition(TileId tileId, out Vector3 center)
        {
            return TryGetTileCenterWorldPosition(tileId.faceNormal, tileId.depth, out center);
        }

        private void SetLayerRecursivelyLocal(GameObject obj, int layer)
        {
            obj.layer = layer;
            for (int i = 0; i < obj.transform.childCount; i++)
            {
                SetLayerRecursivelyLocal(obj.transform.GetChild(i).gameObject, layer);
            }
        }

        // Auto-expand sampling array to the given sqrtRays size (for sqrtRays x sqrtRays grid)
        private List<Vector2> _baseSamples = new();

        private void EnsureBaseSamples(int sqrtRays)
        {
            int requiredSamples = sqrtRays * sqrtRays;
            while (_baseSamples.Count < requiredSamples)
            {
                int currentCount = _baseSamples.Count;
                int currentSqrt = Mathf.RoundToInt(Mathf.Sqrt(currentCount));
                int nextSqrt = currentSqrt + 1;
                int targetCount = nextSqrt * nextSqrt;

                for (int i = currentCount; i < targetCount; i++)
                {
                    int gy = i / nextSqrt;
                    int gx = i % nextSqrt;
                    float fx = (gx + 0.5f) / nextSqrt;
                    float fy = (gy + 0.5f) / nextSqrt;
                    _baseSamples.Add(new Vector2(fx, fy));
                }
            }
        }

        private void Awake()
        {
            s_activeManagers++;
            if (s_activeManagers > 1)
            {
                Debug.LogWarning($"[PlanetTileExplorerCam] Multiple active managers detected ({s_activeManagers}). " +
                    "This may cause tile duplication or performance issues.", this);
            }

            // Ensure we have a valid planet transform
            if (planetTransform == null)
            {
                planetTransform = this.transform;
            }
            _planetCenter = planetTransform.position;

            // Initialize effective raycast mask
            effectiveRaycastMask = raycastLayerMask.value;

            // Precompute depth 0 by default
            PrecomputeTileNormalsForDepth(0);
            _lastPrecomputedDepth = 0;

            // Cache some base samples for raycasting
            EnsureBaseSamples(Mathf.CeilToInt(Mathf.Sqrt(_maxRays)));

            EnsureMeshBuilder();
        }

        private PlanetTileMeshBuilder _meshBuilder;
        private TileCache _tileCache;

        private void EnsureMeshBuilder()
        {
            if (_meshBuilder == null && config != null)
            {
                _meshBuilder = new PlanetTileMeshBuilder(config, config.heightProvider, null, 0, 1f, 0f, false);
                _tileCache = new TileCache();
            }
        }

        private void OnDestroy()
        {
            s_activeManagers--;
            _tileCache?.Dispose();
            _meshBuilder = null;
        }
        {
            if (!debugDrawRays) 
            {
                // clear any stored samples to avoid unbounded growth
                _dbgSampleOrigins.Clear();
                _dbgSampleDirs.Clear();
                _dbgSampleHit.Clear();
                _dbgSampleHitPoints.Clear();
                _dbgSampleIcosphereHitPoints.Clear();
                _dbgSampleTime.Clear();
                return;
            }

            // Draw all stored samples (do not pop them) to avoid flicker when Gizmos updates between frames.
            // Samples are kept for debugSampleLifetime seconds and then removed.
            float now = Time.realtimeSinceStartup;

            // Planet center used for hit markers and optional icosphere drawing
            int count = _dbgSampleOrigins.Count;
            var markerPositions = new List<Vector3>(count);
            var markerTileIds = new List<TileId>(count);
            for (int i = 0; i < count; i++)
            {
                Vector3 o = _dbgSampleOrigins[i];
                Vector3 d = _dbgSampleDirs[i];
                bool hit = _dbgSampleHit[i];
                Gizmos.color = hit ? Color.green : debugRayColor;
                Gizmos.DrawLine(o, o + d * debugRayLength);
                Gizmos.DrawSphere(o + d * Mathf.Min(debugRayLength, 10f), 0.5f);

                // Draw a small red sphere at the actual world-space hit point when the ray hit
                    if (hit && i < _dbgSampleHitPoints.Count)
                    {
                        Vector3 hp = _dbgSampleHitPoints[i];
                        if (hp != Vector3.zero)
                        {
                            // Small gizmo for lightweight visualization (cleared with debug samples)
                            Gizmos.color = debugHitSphereColor;
                            Gizmos.DrawSphere(hp, debugHitGizmoRadius);

                            // Editor-only: optionally draw a larger, solid sphere using Handles so it's clearly visible
#if UNITY_EDITOR
                            if (debugDrawHitHandles)
                            {
                                var prevColor = Handles.color;
                                Handles.color = debugHitSphereColor;
                                Handles.SphereHandleCap(0, hp, Quaternion.identity, debugHitHandleRadius, EventType.Repaint);
                                Handles.color = prevColor;
                            }
#endif
                        }
                    }

                // Draw a magenta marker at the mathematical icosphere intersection (before physics occlusion)
                if (i < _dbgSampleIcosphereHitPoints.Count)
                {
                    Vector3 icoHp = _dbgSampleIcosphereHitPoints[i];
                    if (icoHp != Vector3.zero)
                    {
                        Gizmos.color = debugIntersectionMarkerColor;
                        Gizmos.DrawSphere(icoHp, debugItersectionMarkerRadius);

#if UNITY_EDITOR
                        if (debugDrawIntersectionMarkers)
                        {
                            var prev = Handles.color;
                            Handles.color = debugIntersectionMarkerColor;
                            Handles.SphereHandleCap(0, icoHp, Quaternion.identity, debugItersectionMarkerRadius * 2f, EventType.Repaint);
                            Handles.color = prev;
                        }
#endif
                    }
                }
            }

            // Cull old samples while iterating backwards to keep list indices valid
            for (int i = _dbgSampleOrigins.Count - 1; i >= 0; i--)
            {
                if (now - _dbgSampleTime[i] > debugSampleLifetime)
                {
                    _dbgSampleOrigins.RemoveAt(i);
                    _dbgSampleDirs.RemoveAt(i);
                    _dbgSampleHit.RemoveAt(i);
                    _dbgSampleHitPoints.RemoveAt(i);
                    _dbgSampleIcosphereHitPoints.RemoveAt(i);
                    _dbgSampleTime.RemoveAt(i);
                }
            }

            // Debug: draw sphere bounds in viewport
            if (debugShowSphereBounds && GameCamera != null)
            {
                Camera cam = GameCamera.GetComponent<Camera>();
                if (cam != null)
                {
                    float cameraDistance = (cam.transform.position - _planetCenter).magnitude;
                    float planetRadius = config != null ? config.baseRadius : 1f;
                    
                    if (cameraDistance > planetRadius && planetRadius > 0f)
                    {
                        float angularRadius = Mathf.Asin(planetRadius / cameraDistance);
                        float vFovHalf = cam.fieldOfView * Mathf.Deg2Rad * 0.5f;
                        float sphereViewportRadius = Mathf.Tan(angularRadius) / Mathf.Tan(vFovHalf);
                        sphereViewportRadius = Mathf.Clamp(sphereViewportRadius, 0f, 1.0f);
                        
                        // Draw sphere bounds as a circle in screen space
                        Gizmos.color = Color.cyan;
                        Vector3 screenCenter = cam.ViewportToWorldPoint(new Vector3(0.5f, 0.5f, cam.nearClipPlane + 1f));
                        float distance = cam.nearClipPlane + 1f;
                        float worldRadius = sphereViewportRadius * distance * Mathf.Tan(vFovHalf) * 2f;
                        
                        // Draw circle approximation
                        int segments = 32;
                        Vector3 prevPoint = screenCenter + cam.transform.right * worldRadius;
                        for (int i = 1; i <= segments; i++)
                        {
                            float angle = (float)i / segments * 2f * Mathf.PI;
                            Vector3 point = screenCenter + cam.transform.right * (Mathf.Cos(angle) * worldRadius) 
                                                        + cam.transform.up * (Mathf.Sin(angle) * worldRadius);
                            Gizmos.DrawLine(prevPoint, point);
                            prevPoint = point;
                        }
                    }
                }
            }

            // Optionally draw icosphere tile outlines at the current depth (cached rebuild on depth change)
            if (debugDrawIcosphereTiles)
            {
                int depth = _currentDepth;
                float planetRadius = config != null ? config.baseRadius : 1f;

                if (!debugUsePersistentIcosphereObject)
                {
                    // Fallback: draw once immediately (not persistent)
                    DrawIcosphereTiles(depth, planetRadius);
                }
                else
                {
                    // Ensure persistent scene object exists and matches depth
                    if (_icosphereDebugGO == null || depth != _lastIcosphereDepth)
                    {
                        BuildOrUpdateIcosphereDebugObject(depth, planetRadius);
                        _lastIcosphereDepth = depth;
                    }
                }
            }
            else
            {
                // If the debug option was turned off, ensure any persistent debug object is removed
                if (_icosphereDebugGO != null)
                {
                    if (Application.isPlaying) Destroy(_icosphereDebugGO); else DestroyImmediate(_icosphereDebugGO);
                    _icosphereDebugGO = null;
                    _icosphereDebugMesh = null;
                }
                _lastIcosphereDepth = -1;
            }
        }

        // Draw triangular tile outlines for a given icosphere depth
        private void DrawIcosphereTiles(int depth, float planetRadius)
        {
            Gizmos.color = debugIcosphereTileColor;

            int tilesPerEdge = 1 << depth;
            int tilesCount = IcosphereMapping.GetValidTileCountForDepth(depth);

            // Iterate over faces and tile X/Y within triangular face bounds
            for (int face = 0; face < 20; face++)
            {
                for (int x = 0; x < tilesPerEdge; x++)
                {
                    for (int y = 0; y < tilesPerEdge; y++)
                    {
                        if (!IcosphereMapping.IsValidTileIndex(x, y, depth)) continue;

                        // Compute triangle corners in barycentric coordinates (u,v)
                        float u0 = (float)x / tilesPerEdge;
                        float v0 = (float)y / tilesPerEdge;
                        float u1 = (float)(x + 1) / tilesPerEdge;
                        float v1 = v0;
                        float u2 = u0;
                        float v2 = (float)(y + 1) / tilesPerEdge;

                        Vector3 p0 = IcosphereMapping.BarycentricToWorldDirection(face, u0, v0) * planetRadius + _planetCenter;
                        Vector3 p1 = IcosphereMapping.BarycentricToWorldDirection(face, u1, v1) * planetRadius + _planetCenter;
                        Vector3 p2 = IcosphereMapping.BarycentricToWorldDirection(face, u2, v2) * planetRadius + _planetCenter;

                        Gizmos.DrawLine(p0, p1);
                        Gizmos.DrawLine(p1, p2);
                        Gizmos.DrawLine(p2, p0);
                    }
                }
            }
        }

        // Build or update a persistent scene GameObject containing a line mesh for icosphere tile outlines
        private void BuildOrUpdateIcosphereDebugObject(int depth, float planetRadius)
        {
            // Cleanup existing
            if (_icosphereDebugGO != null)
            {
                if (Application.isPlaying)
                    Destroy(_icosphereDebugGO);
                else
                    DestroyImmediate(_icosphereDebugGO);
                _icosphereDebugGO = null;
                _icosphereDebugMesh = null;
            }

            // Create container
            _icosphereDebugGO = new GameObject("IcosphereTileOutline_Debug");
            _icosphereDebugGO.hideFlags = HideFlags.DontSaveInBuild | HideFlags.HideInHierarchy;
            // Parent to planet transform when available so the debug object follows the planet
            Transform parent = planetTransform != null ? planetTransform : this.transform;
            _icosphereDebugGO.transform.SetParent(parent, false);
            _icosphereDebugGO.transform.localPosition = Vector3.zero;
            _icosphereDebugGO.transform.localRotation = Quaternion.identity;

            var mf = _icosphereDebugGO.AddComponent<MeshFilter>();
            var mr = _icosphereDebugGO.AddComponent<MeshRenderer>();

            // Create a simple unlit material for lines
            if (_icosphereDebugMaterial == null)
            {
                Shader s = Shader.Find("Hidden/Internal-Colored");
                _icosphereDebugMaterial = new Material(s);
                _icosphereDebugMaterial.hideFlags = HideFlags.DontSaveInBuild | HideFlags.HideAndDontSave;
                _icosphereDebugMaterial.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
                _icosphereDebugMaterial.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                _icosphereDebugMaterial.SetInt("_Cull", (int)UnityEngine.Rendering.CullMode.Off);
                _icosphereDebugMaterial.SetInt("_ZWrite", 0);
            }

            mr.sharedMaterial = _icosphereDebugMaterial;

            // Build subdivided, sphere-projected line vertex list
            var linePoints = new List<Vector3>();
            int tilesPerEdge = 1 << depth;
            int subdivisions = 6;
            float curvedMultiplier = Mathf.Clamp(curvedIcosphereRadiusMultiplier, 0.95f, 1.2f);
            float targetRadius = planetRadius * curvedMultiplier;

            for (int face = 0; face < 20; face++)
            {
                for (int x = 0; x < tilesPerEdge; x++)
                {
                    for (int y = 0; y < tilesPerEdge; y++)
                    {
                        if (!IcosphereMapping.IsValidTileIndex(x, y, depth)) continue;

                        // triangle corners in barycentric coords
                        float u0 = (float)x / tilesPerEdge;
                        float v0 = (float)y / tilesPerEdge;
                        float u1 = (float)(x + 1) / tilesPerEdge;
                        float v1 = v0;
                        float u2 = u0;
                        float v2 = (float)(y + 1) / tilesPerEdge;

                        // helper to sample along an edge from (ua,va) to (ub,vb)
                        System.Action<float,float,float,float> SampleEdge = (ua, va, ub, vb) =>
                        {
                            Vector3 prev = Vector3.zero;
                            for (int s = 0; s <= subdivisions; s++)
                            {
                                float t = (float)s / (float)subdivisions;
                                float uu = Mathf.Lerp(ua, ub, t);
                                float vv = Mathf.Lerp(va, vb, t);
                                Vector3 dir = IcosphereMapping.BarycentricToWorldDirection(face, uu, vv).normalized;
                                Vector3 world = dir * targetRadius + _planetCenter;
                                if (s > 0)
                                {
                                    // add segment prev->world as a line (two points)
                                    linePoints.Add(prev);
                                    linePoints.Add(world);
                                }
                                prev = world;
                            }
                        };

                        // sample each of the triangle's three edges (p0->p1, p1->p2, p2->p0)
                        SampleEdge(u0, v0, u1, v1);
                        SampleEdge(u1, v1, u2, v2);
                        SampleEdge(u2, v2, u0, v0);

                    }
                }
            }

            // Build mesh with line topology
            _icosphereDebugMesh = new Mesh();
            _icosphereDebugMesh.name = "IcosphereTileOutlineMesh";
            _icosphereDebugMesh.SetVertices(linePoints);

            int[] indices = new int[linePoints.Count];
            for (int i = 0; i < indices.Length; i++) indices[i] = i;
            _icosphereDebugMesh.SetIndices(indices, MeshTopology.Lines, 0);
            _icosphereDebugMesh.RecalculateBounds();

            mf.sharedMesh = _icosphereDebugMesh;

            // Apply color via material
            if (_icosphereDebugMaterial.HasProperty("_Color"))
                _icosphereDebugMaterial.SetColor("_Color", debugIcosphereTileColor);
            else if (_icosphereDebugMaterial.HasProperty("color"))
                _icosphereDebugMaterial.SetColor("color", debugIcosphereTileColor);
        }

        // Helper: set layer recursively on GameObject and children
        private void SetLayerRecursivelyLocal(GameObject obj, int layer)
        {
            if (obj == null) return;
            obj.layer = layer;
            foreach (Transform t in obj.transform)
            {
                SetLayerRecursivelyLocal(t.gameObject, layer);
            }
        }

        // ----- Internal state -----
        private PlanetTileMeshBuilder meshBuilder;
        private readonly Dictionary<TileId, GameObject> tileObjects = new();
        private readonly Dictionary<TileId, float> tileSpawnTimes = new();
        private Vector2[] _baseSamples = null;
        private int _baseSampleGrid = 0; // sqrtRays
        private int _sampleCapacity = 0;

        private void EnsureBaseSamples(int sqrtRays)
        {
            if (_baseSamples != null && _baseSampleGrid == sqrtRays) return;
            _baseSampleGrid = sqrtRays;
            _sampleCapacity = sqrtRays * sqrtRays;
            _baseSamples = new Vector2[_sampleCapacity];
            int idx = 0;
            for (int y = 0; y < sqrtRays; y++)
            {
                for (int x = 0; x < sqrtRays; x++)
                {
                    _baseSamples[idx++] = new Vector2((x + 0.5f) / sqrtRays, (y + 0.5f) / sqrtRays);
                }
            }
        }

        private Coroutine _heuristicCoroutine;
        private float _lastHeuristicTime = 0f;
        private const float HeuristicInterval = 1f / 30f; // target ~30 Hz

        // Current depth (derived from camera state). Use _currentDepth for all tile logic.
        private int _currentDepth = 0;

        /// <summary>
        /// Initialize mesh builder reference.
        /// </summary>
        private void Awake()
        {
            // Diagnostic: count active manager instances
            s_activeManagers++;
            if (s_activeManagers > 1)
            {
                Debug.LogWarning($"[PlanetTileVisibilityManager] Multiple active instances detected: {s_activeManagers}. This may cause duplicate spawning behaviour.", this);
            }

            if (config == null)
            {
                Debug.LogWarning("[PlanetTileExplorerCam] TerrainConfig is not assigned in the inspector. Mesh builder initialization will be deferred until config is available.");
            }

            _planetCenter = planetTransform != null ? planetTransform.position : this.transform.position;

            // Attempt to initialize mesh builder if config present; otherwise defer until first use.
            EnsureMeshBuilder();

            // Runtime guard: ensure a dedicated terrain tile layer exists and is excluded from raycasts
            // Prefer an existing layer named "TerrainTiles". If not present, use the configured terrainTileLayer as-is.
            int runtimeTileLayer = terrainTileLayer;
            string layerName = "TerrainTiles";
            int found = LayerMask.NameToLayer(layerName);
            if (found != -1)
            {
                runtimeTileLayer = found;
            }

            // Update the configured tile layer. We will NOT modify the serialized raycastLayerMask here.
            terrainTileLayer = runtimeTileLayer;

            // Honor the inspector-selected raycastLayerMask at runtime without mutating it.
            // Store the runtime integer mask in effectiveRaycastMask so any Physics.Raycast
            // calls can use it while leaving the serialized value unchanged for the user.
            effectiveRaycastMask = raycastLayerMask.value;

            // initialization log removed
        }

        // Lazily initialize the mesh builder when config becomes available.
        private void EnsureMeshBuilder()
        {
            if (meshBuilder != null) return;
            if (config == null)
            {
                // nothing to do yet
                return;
            }
            meshBuilder = new PlanetTileMeshBuilder(config, config.heightProvider, null, 0, 1, 0f, false);
            // mesh builder initialization: silent in production
        }

        private void OnDestroy()
        {
            s_activeManagers = Math.Max(0, s_activeManagers - 1);
        }

        /// <summary>
        /// Update depth from the camera and schedule the heuristic coroutine (single-run enforcement).
        /// </summary>
        private void Update()
        {
            // Derive depth from camera proportional distance (CameraController exposes ProportionalDistance [0..1])
            if (GameCamera != null)
            {
                int newDepth = ComputeDepthFromCamera();
                if (newDepth != _currentDepth)
                {
                    _currentDepth = newDepth;
                }
            }

            // Schedule heuristic if not already running and interval elapsed
            if (_heuristicCoroutine == null && Time.time - _lastHeuristicTime >= HeuristicInterval)
            {
                _lastHeuristicTime = Time.time;
                _heuristicCoroutine = StartCoroutine(RunTileRaycastHeuristicCoroutine());
            }
        }

        /// <summary>
        /// Compute the desired icosphere depth based on the current camera distance and configured parameters.
        /// </summary>
        private int ComputeDepthFromCamera()
        {
            if (GameCamera == null || cam == null) return _currentDepth;

            // Respect the configured maximum distance but clamp to a sensible positive value
            int maxDist = Math.Max(1, depthLevelMaxDistance);
            // If the CameraController specifies a smaller maxDistance, use the lesser of the two
            int effectiveMax = Math.Min((int)GameCamera.maxDistance, maxDist);

            // Normalized distance in [0,1]
            float t = Mathf.Clamp01(GameCamera.distance / (float)effectiveMax);

            // Apply bias exponent (1 = linear, >1 biases bins toward higher distances)
            float biasedT = Mathf.Pow(t, Mathf.Max(0.0001f, binBias));

            // Reverse lerp so that closer distances map to higher detail (larger depth)
            int newDepth = Mathf.Clamp(Mathf.FloorToInt((1 - biasedT) * (maxDepth + 1)), 0, maxDepth);
            return newDepth;
        }

        /// <summary>
        /// Fetch or spawn a tile GameObject for the given id/resolution.
        /// This function ensures a recently spawned tile won't be immediately culled.
        /// </summary>
        public GameObject TrySpawnTile(TileId id, int resolution)
        {
            // Get camera reference for visibility checks
            Camera cam = GameCamera != null ? GameCamera.GetComponent<Camera>() : null;
            int terrainTileLayer = LayerMask.NameToLayer("TerrainTiles");
            
            if (tileObjects.TryGetValue(id, out var go))
            {
                if (go != null)
                {
                    go.SetActive(true);
                    // Use centralized tile functionality for existing tiles
                    var existingTile = go.GetComponent<PlanetTerrainTile>();
                    if (existingTile != null)
                    {
                        existingTile.SetVisible(true);
                        // Log diagnostic info using centralized method
                        var diagnostics = existingTile.GetDiagnosticInfo(cam);
                    }
                    return go;
                }

                // stale entry: remove it and continue to spawn
                tileObjects.Remove(id);
            }

            // record spawn time to prevent immediate destruction
            tileSpawnTimes[id] = Time.time;

            var tileData = new TileData { id = id, resolution = resolution, isBaked = true };
            float dummyMin = 0f, dummyMax = 0f;
            // Try to reuse cached mesh first using discrete precomputed entry (face,x,y,depth)
            // Mesh cache entry placeholder (not used directly here)
            if (GetPrecomputedEntry(id, out var preEntry))
            {
                var key = new TileMeshKey(preEntry.face, preEntry.x, preEntry.y, id.depth);
                if (tileMeshCache.TryGetValue(key, out var cacheEntry))
                {
                    tileData.mesh = cacheEntry.mesh;
                    // Restore the exact center used when the mesh was cached so positions match
                    tileData.center = cacheEntry.centerWorld;
                }
                else
                {
                    // Ensure mesh builder is available; attempt lazy init if config was assigned later.
                    EnsureMeshBuilder();
                    if (meshBuilder != null)
                    {
                        meshBuilder.BuildTileMesh(tileData, ref dummyMin, ref dummyMax);
                        if (tileData.mesh != null)
                        {
                            // store a shared copy in the cache (shared across spawned GOs)
                            tileMeshCache[key] = new TileMeshCacheEntry { mesh = tileData.mesh, centerWorld = tileData.center };
                        }
                    }
                    else
                    {
                        Debug.LogError("[PlanetTileExplorerCam] Cannot build tile mesh because meshBuilder is null and TerrainConfig is missing.");
                    }
                }
            }
            else
            {
                // If we could not get a precomputed entry, fall back to attempting to reactivate any existing tile
                // that matches the requested faceNormal/depth approximately.
                foreach (var kv in tileObjects)
                {
                    var k = kv.Key;
                    if (k.depth != id.depth) continue;
                    float dot = Vector3.Dot(k.faceNormal.normalized, id.faceNormal.normalized);
                    if (dot > 0.9999f)
                    {
                        var existingGo = kv.Value;
                        if (existingGo != null)
                        {
                            existingGo.SetActive(true);
                            SetLayerRecursivelyLocal(existingGo, terrainTileLayer);
                            return existingGo;
                        }
                    }
                }
                // As final fallback, build directly using meshBuilder
                EnsureMeshBuilder();
                if (meshBuilder != null)
                {
                    meshBuilder.BuildTileMesh(tileData, ref dummyMin, ref dummyMax);
                    // If there is no precomputed entry, compute a reasonable center from the id faceNormal
                    // so spawned GameObjects are positioned on the planet surface rather than at origin.
                    if (tileData.center == Vector3.zero)
                    {
                        float radius = _planetRadius;
                        float centerHeight = 0f;
                        if (config != null) centerHeight = (config.seaLevel);
                        tileData.center = id.faceNormal.normalized * (radius + centerHeight);
                    }
                }
            }

            // Use centralized tile creation and configuration
            Transform spawnParent = planetTransform != null ? planetTransform : this.transform;
            
            var tileGO = new GameObject($"Tile_{id.faceNormal}_d{id.depth}");
            tileGO.transform.position = tileData.center;
            tileGO.transform.SetParent(spawnParent, true);
            
            var terrainTile = tileGO.AddComponent<PlanetTerrainTile>();
            // Provide a collider mesh generator that centers the collider relative to the computed tileData.center
            terrainTile.Initialize(id, tileData, colliderMeshGenerator: (TileId tid) => CreateBaseSphereColliderMesh(tid, tileData.center));
            
            // Use centralized material and layer configuration
            Material materialToUse = terrainMaterial;
            if (materialToUse == null)
            {
                // Try to auto-load the Land material from Assets/Materials/
                materialToUse = UnityEditor.AssetDatabase.LoadAssetAtPath<Material>("Assets/Materials/Land.mat");
                
                if (materialToUse == null)
                {
                    // Create a basic material if none assigned and Land.mat not found
                    materialToUse = new Material(Shader.Find("Standard"));
                    materialToUse.name = "Default Terrain Material";
                    materialToUse.color = Color.white;
                    Debug.LogWarning("[TILE] No terrain material assigned and could not find Land.mat, using default Standard material");
                }
                else
                {
                }
            }
            terrainTile.ConfigureMaterialAndLayer(materialToUse, terrainTileLayer);
            
            // Ensure mesh is properly assigned - Initialize should have done this, but double-check
            if (tileData.mesh != null)
            {
                if (terrainTile.meshFilter != null)
                {
                    terrainTile.meshFilter.sharedMesh = tileData.mesh;
                }
                if (terrainTile.meshRenderer != null)
                {
                    terrainTile.meshRenderer.enabled = true;
                }
                terrainTile.ShowVisualMesh();
            }
            else
            {
                Debug.LogWarning($"[TILE] No mesh in tileData for tile {id}");
            }
            
            tileObjects[id] = tileGO;
            
            if (tileGO != null)
            {
                // Use centralized visibility and diagnostic functionality
                terrainTile.SetVisible(true);
                var diagnostics = terrainTile.GetDiagnosticInfo(cam);
                
                // Additional mesh debugging
                if (tileData.mesh != null)
                {
                    if (terrainTile.meshRenderer != null)
                    {
                    }
                }
            }
            else
            {
                Debug.LogError($"[TILE] FAILED to spawn tile: {id.faceNormal}_{id.depth}");
            }

            return tileGO;
        }

        /// <summary>
        /// Destroy a tile if it exists and it's older than the safety window.
        /// </summary>
        public void DestroyTile(TileId id)
        {
            if (!tileObjects.TryGetValue(id, out var go) || go == null) return;

            // Use centralized safety check
            var terrainTile = go.GetComponent<PlanetTerrainTile>();
            if (terrainTile != null && terrainTile.IsTooYoungToDestroy())
            {
                // skip destruction for newly spawned tiles
                return;
            }

            // Instead of destroying the GameObject, simply deactivate it so it can be reused
            // and so meshes/objects remain in the scene (faster to re-enable than rebuild).
            try
            {
                if (terrainTile != null)
                {
                    terrainTile.SetVisible(false);
                }
                go.SetActive(false);
            }
            catch
            {
                // In case the GameObject has been destroyed externally, remove entries safely
                tileObjects.Remove(id);
                tileSpawnTimes.Remove(id);
            }
        }

        /// <summary>
        /// Centralized tile lifecycle management: spawn or refresh tiles in hitTiles,
        /// destroy tiles that were not hit this pass, and remove tiles with mismatched depth.
        /// </summary>
        private void ManageTileLifecycle(HashSet<TileId> hitTiles, int depth)
        {
            // Snapshot existing keys to avoid modifying collection while iterating
            var existingKeys = tileObjects.Keys.ToList();

            // Spawn/refresh tiles that were hit
            int spawnedCount = 0;
            int updatedCount = 0;
            foreach (var id in hitTiles)
            {
                int resolution = ResolveResolutionForDepth(depth);
                bool wasExisting = tileObjects.ContainsKey(id);

                GameObject tileGO = TrySpawnTile(id, resolution);

                if (wasExisting) updatedCount++; else spawnedCount++;
                existingKeys.Remove(id);
            }

            // Destroy any tiles that were not hit this pass
            int destroyedCount = 0;
            foreach (var id in existingKeys)
            {
                DestroyTile(id);
                destroyedCount++;
            }

            // Additionally remove any tiles with mismatched depth
            var mismatched = tileObjects.Keys.Where(k => k.depth != depth).ToList();
            foreach (var id in mismatched)
            {
                DestroyTile(id);
            }
        }

        /// <summary>
        /// Raycast-based heuristic that samples the camera viewport and spawns tiles for hit locations.
        /// Single-running coroutine; yields periodically for responsiveness.
        /// </summary>
        private System.Collections.IEnumerator RunTileRaycastHeuristicCoroutine()
        {
            // Validate required references
            if (GameCamera == null)
            {
                _heuristicCoroutine = null;
                yield break;
            }

            if (cam == null)
            {
                _heuristicCoroutine = null;
                yield break;
            }

            int raysToCast = Mathf.Max(1, _maxRays);
            int depth = _currentDepth;
            
            
            int sqrtRays = Mathf.CeilToInt(Mathf.Sqrt(raysToCast));
            EnsureBaseSamples(sqrtRays);
            
            // Calculate sphere's angular radius and viewport bounds for adaptive ray distribution
            float cameraDistance = (cam.transform.position - _planetCenter).magnitude;
            
            // Calculate angular radius of sphere as seen from camera
            _sphereViewportRadius = 0f;
            if (cameraDistance > _planetRadius && _planetRadius > 0f)
            {
                float angularRadius = Mathf.Asin(_planetRadius / cameraDistance);
                // Convert angular radius to viewport radius using camera's field of view
                float vFovHalf = cam.fieldOfView * Mathf.Deg2Rad * 0.5f;
                _sphereViewportRadius = Mathf.Tan(angularRadius) / Mathf.Tan(vFovHalf);
                _sphereViewportRadius = Mathf.Clamp(_sphereViewportRadius, 0f, 1.0f);
            }
            
            // Deterministic sampling over the precomputed grid
            int rayCountIter = sqrtRays * sqrtRays;
            HashSet<TileId> hitTiles = new HashSet<TileId>();
            // Ensure precomputed normals and colliders exist for this depth
            if (_lastPrecomputedDepth != depth)
            {
                PrecomputeTileNormalsForDepth(depth);
                _lastPrecomputedDepth = depth;
            }

            int physicsHits = 0;
            int mappingHits = 0;
            int mappingMisses = 0;
            int fallbackHits = 0;
            for (int s = 0; s < rayCountIter; s++)
            {
                var ray = GetRayForSample(s);

                // First, test physics colliders (tile collider meshes) to find the exact tile slot hit.
                RaycastHit ph;
                if (Physics.Raycast(ray.origin, ray.direction, out ph, Mathf.Infinity, effectiveRaycastMask))
                {
                    physicsHits++;
                    // Resolve physics hit to a PlanetTerrainTile (per-tile colliders)
                    if (ph.collider != null)
                    {
                        var terrainTile = ph.collider.GetComponentInParent<PlanetTerrainTile>();
                        if (terrainTile != null)
                        {
                            mappingHits++;
                            var tdata = terrainTile.tileData;
                            if (tdata != null)
                            {
                                var tileId = terrainTile.tileId;
                                hitTiles.Add(tileId);

                                // Preserve debug sampling/visualization
                                if (debugDrawRays)
                                {
                                    _dbgSampleOrigins.Add(ray.origin);
                                    _dbgSampleDirs.Add(ray.direction.normalized);
                                    _dbgSampleHit.Add(true);
                                    _dbgSampleHitPoints.Add(ph.point);
                                    _dbgSampleIcosphereHitPoints.Add(tdata.center);
                                    _dbgSampleTime.Add(Time.realtimeSinceStartup);
                                }

                                if (debugDrawRays || Application.isEditor)
                                {
                                }

                                continue;
                            }
                        }
                    }
                    // physics hit but not mapped to registry entry
                    mappingMisses++;
                    if (debugDrawRays || Application.isEditor)
                    {
                        string cname = ph.collider != null ? ph.collider.name : "<null>";
                        int hitId = ph.collider != null ? ph.collider.GetInstanceID() : -1;
                        Debug.LogWarning($"[RAY->MISSING] Physics hit collider '{cname}' id={hitId} could not be mapped to a PlanetTerrainTile. colliderLayer={ph.collider?.gameObject.layer} effectiveMask={effectiveRaycastMask}");

                        // Also perform an unmasked raycast to see what collider would be hit ignoring masks
                        if (Physics.Raycast(ray.origin, ray.direction, out var unmaskedHit, Mathf.Infinity, ~0))
                        {
                        }
                    }
                }

                // No physics collider hit - fall back to mathematical sphere intersection using centralized method
                var sphereHitPoint = PlanetTerrainTile.GetSphereHitPoint(ray, _planetCenter, _planetRadius, curvedIcosphereRadiusMultiplier);
                var hitDirection = (sphereHitPoint - _planetCenter).normalized;
                var closest = GetClosestPrecomputedTile(hitDirection);
                int entryIdxFallback = _precomputedTilesForDepth.IndexOf(closest);
                // Accept fallback tile for any mathematical hit (do not filter by facing)
                var tileIdFallback = new TileId(closest.face, closest.x, closest.y, depth) { canonicalIndex = entryIdxFallback };
                hitTiles.Add(tileIdFallback);
                fallbackHits++;

                // Diagnostic: check for any colliders along this ray up to the curved tile center
                float occlusionDist = (closest.centerWorld - ray.origin).magnitude;
                if (Physics.Raycast(ray.origin, ray.direction, out var anyHit, occlusionDist - 0.01f, ~0))
                {
                }
            }

            if (debugDrawRays || Application.isEditor)
            {
            }

            // Debug dump: list selected hit tiles with their precomputed index and center position
            if (debugDrawRays || Application.isEditor)
            {
                try
                {
                    var sb = new System.Text.StringBuilder();
                    foreach (var id in hitTiles)
                    {
                        if (GetPrecomputedIndex(id, out int idx, out var e))
                        {
                            sb.AppendFormat("[idx={0} F{1}({2},{3}) center={4}] ", idx, e.face, e.x, e.y, e.centerWorld);
                        }
                        else
                        {
                            sb.AppendFormat("[depth={0} faceNormal={1}] ", id.depth, id.faceNormal);
                        }
                    }

                    // Additional per-hit visibility diagnostics: whether each hit center is in front of the camera
                    if (cam != null)
                    {
                        var sb2 = new System.Text.StringBuilder();
                        Vector3 camPos = cam.transform.position;
                        Vector3 camFwd = cam.transform.forward;
                        foreach (var id in hitTiles)
                        {
                            if (GetPrecomputedIndex(id, out int idx, out var e))
                            {
                                Vector3 rel = e.centerWorld - camPos;
                                float dist = rel.magnitude;
                                float angle = Vector3.Angle(camFwd, rel);
                                bool inFront = Vector3.Dot(camFwd, rel) > 0f;
                                sb2.AppendFormat("[idx={0} F{1}({2},{3}) inFront={4} angleDeg={5:F1} dist={6:F2}] ", idx, e.face, e.x, e.y, inFront, angle, dist);
                            }
                            else
                            {
                                sb2.AppendFormat("[depth={0} faceNormal={1}] ", id.depth, id.faceNormal);
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[RAY HITS LIST] failed to enumerate hitTiles: {ex.Message}");
                }
            }

            // Manage tile lifecycle (spawn/update/destroy) for the set of hit tiles
            // If depth 0 and no tiles exist yet, seed the hit set with all precomputed entries
            // to ensure one tile per icosphere face is spawned at startup. This preserves
            // the raycast-driven behavior for subsequent frames while fixing the 7-tile
            // startup symptom observed in the editor/play mode.
            if (depth == 0 && tileObjects.Count == 0)
            {
                if (s_precomputedRegistry.TryGetValue(0, out var reg) && reg != null)
                {
                    foreach (var e in reg)
                    {
                        var id = new TileId(e.face, e.x, e.y, 0);
                        hitTiles.Add(id);
                    }
                }
            }

            ManageTileLifecycle(hitTiles, depth);

            _heuristicCoroutine = null;
        }

        private Ray GetRayForSample(int sampleIndex)
        {
            float biasStrength = GameCamera != null ? GameCamera.ProportionalDistance : 0f;

            float su = _baseSamples[sampleIndex].x;
            float sv = _baseSamples[sampleIndex].y;// Apply adaptive radial bias based on camera distance
                if (biasStrength > 0f && _sphereViewportRadius > 0f)
                {
                    // Convert to centered coordinates [-0.5, 0.5]
                    float centeredU = su - 0.5f;
                    float centeredV = sv - 0.5f;
                    float currentRadius = Mathf.Sqrt(centeredU * centeredU + centeredV * centeredV);

                    if (currentRadius > 0f)
                    {
                        // Normalize the sample radius to [0,1] using the true maximum possible
                        // radius for the centered square (corner magnitude = 0.5*sqrt(2)).
                        float maxSampleRadius = 0.5f * Mathf.Sqrt(2f);
                        float normalizedRadius = Mathf.Clamp01(currentRadius / maxSampleRadius);

                        // Compute a biased normalized radius in [0,1]
                        float biasedNormalized = Mathf.Pow(normalizedRadius, radialBiasExponent);

                        // Blend between original and biased radii according to bias strength
                        float blendedNormalized = Mathf.Lerp(normalizedRadius, biasedNormalized, biasStrength);

                        // Map blended normalized radius into viewport-space using the visible sphere viewport radius
                        float targetViewportRadius = blendedNormalized * _sphereViewportRadius;

                        // Convert back to centered viewport coordinates by scaling the current vector
                        float scale = targetViewportRadius / currentRadius;
                        scale = float.IsFinite(scale) ? scale : 0f;
                        centeredU *= scale;
                        centeredV *= scale;

                        su = centeredU + 0.5f;
                        sv = centeredV + 0.5f;

                        // Clamp to valid viewport range
                        su = Mathf.Clamp01(su);
                        sv = Mathf.Clamp01(sv);
                    }
                }

            return cam.ViewportPointToRay(new Vector3(su, sv, 0f));
        }

        private Vector3 GetSphereHitPoint(Ray ray)
        {

            // IMPROVED: Clamp rays to planet's visible circumference for 100% hit rate when zoomed out
            Vector3 camToPlanet = _planetCenter - ray.origin;
            float projectionLength = Vector3.Dot(camToPlanet, ray.direction);
            Vector3 closestPoint = ray.origin + ray.direction * projectionLength;
            float distToCenter = (closestPoint - _planetCenter).magnitude;

            if (distToCenter > _planetRadius)
            {
                // Ray would miss the sphere - clamp it to hit the sphere edge
                // Use the planet's visible horizon circle from the camera's perspective
                Vector3 rayToPlanetCenter = (_planetCenter - ray.origin).normalized;
                Vector3 rayDirection = ray.direction.normalized;

                // Calculate the closest point on the sphere surface that this ray direction can hit
                float dot = Vector3.Dot(rayDirection, rayToPlanetCenter);
                if (dot > 0f) // Ray pointing towards planet
                {
                    // Find intersection with planet's visible horizon
                    Vector3 perpendicular = (rayDirection - dot * rayToPlanetCenter).normalized;
                    Vector3 tangentPoint = _planetCenter + perpendicular * _planetRadius;
                    ray.direction = (tangentPoint - ray.origin).normalized;
                }
                else
                {
                    // Ray pointing away from planet - redirect to nearest visible point
                    Vector3 nearestVisible = _planetCenter + rayToPlanetCenter * _planetRadius;
                    ray.direction = (nearestVisible - ray.origin).normalized;
                }
            }

            // Always use mathematical ray-sphere intersection for tile detection
            float a = Vector3.Dot(ray.direction, ray.direction);
            float b = 2f * Vector3.Dot(ray.direction, ray.origin - _planetCenter);
            float c = (ray.origin - _planetCenter).sqrMagnitude - _planetRadius * _planetRadius;
            float discriminant = b * b - 4f * a * c;
            bool sphereHit = discriminant >= 0f;

            float t0 = -1f;
            Vector3 sphereHitPoint = Vector3.zero;
            if (sphereHit)
            {
                float sqrtDisc = Mathf.Sqrt(Mathf.Max(0f, discriminant));
                t0 = (-b - sqrtDisc) / (2f * a);
                if (t0 < 0f)
                {
                    sphereHit = false; // intersection behind camera
                }
                else
                {
                    // base (mathematical) hit point along the ray
                    sphereHitPoint = ray.origin + ray.direction * t0;
                    // Project hit point to the CURVED tile-slot icosphere radius (configured multiplier)
                    float curvedMultiplier = Mathf.Clamp(curvedIcosphereRadiusMultiplier, 0.95f, 1.2f);
                    Vector3 curvedProjected = sphereHitPoint.normalized * (_planetRadius * curvedMultiplier);
                    // compute curved-projected distance along the ray from origin
                    float tCurved = (curvedProjected - ray.origin).magnitude;
                    // set the returned hit point to the curved projection
                    sphereHitPoint = curvedProjected;
                }
            }

            // Optional physics occlusion check: perform a Physics.Raycast from the camera
            // towards the sphere hit point and treat the ray as occluded if any collider
            // on the inspector-selected layers intercepts before the sphere surface.
            Vector3 debugHitPoint = Vector3.zero;
            if (sphereHit)
            {
                // Determine occlusion distance: use the curved-projected intersection distance
                // so colliders placed at the curved radius are considered occluders.
                float occlusionDist = t0;
                if (sphereHitPoint != Vector3.zero)
                {
                    occlusionDist = (sphereHitPoint - ray.origin).magnitude;
                }
                float maxCheckDist = Mathf.Max(0f, occlusionDist - 0.01f);
                if (maxCheckDist > 0f)
                {
                    if (Physics.Raycast(ray.origin, ray.direction, out RaycastHit ph, maxCheckDist, effectiveRaycastMask))
                    {
                        // Physics reported an occluder before the planet's curved surface - mark as miss
                        sphereHit = false;
                        debugHitPoint = ph.point;
                    }
                    else
                    {
                        debugHitPoint = sphereHitPoint;
                    }
                }
                else
                {
                    debugHitPoint = sphereHitPoint;
                }
            }

            if (debugDrawRays)
            {
                _dbgSampleOrigins.Add(ray.origin);
                _dbgSampleDirs.Add(ray.direction.normalized);
                _dbgSampleHit.Add(sphereHit);
                // store the post-occlusion debug hit (what we currently treat as the visible hit)
                _dbgSampleHitPoints.Add(sphereHit ? debugHitPoint : debugHitPoint);
                // store the mathematical icosphere intersection point (before physics occlusion)
                _dbgSampleIcosphereHitPoints.Add(sphereHit ? sphereHitPoint : Vector3.zero);
                _dbgSampleTime.Add(Time.realtimeSinceStartup);
            }

            return sphereHitPoint;

        }

        /// <summary>
        /// Create a base sphere mesh for collider (no height displacement) to ensure consistent physics.
        /// </summary>
        private Mesh CreateBaseSphereColliderMesh(TileId id)
        {
            return CreateBaseSphereColliderMesh(id, Vector3.zero);
        }

        // Overload: create collider mesh using an explicit world-space center so the collider
        // can be aligned exactly with the visual tile GameObject position.
        private Mesh CreateBaseSphereColliderMesh(TileId id, Vector3 worldCenter)
        {
            // Create a simple flat icosphere mesh for collider
            var mesh = new Mesh();
            mesh.name = $"FlatCollider_{id.faceNormal}_d{id.depth}";
            
            // Create a small unit octahedron centered at origin to serve as a deterministic collider.
            // This avoids mismatches between precomputed corner positions and the final tile center.
            var vertices = new Vector3[] {
                new Vector3(0, 0, 1),
                new Vector3(1, 0, 0),
                new Vector3(0, 1, 0),
                new Vector3(-1, 0, 0),
                new Vector3(0, -1, 0),
                new Vector3(0, 0, -1)
            };
            var triangles = new int[] {
                0, 2, 1,
                0, 1, 4,
                0, 4, 3,
                0, 3, 2,
                5, 1, 2,
                5, 4, 1,
                5, 3, 4,
                5, 2, 3
            };
            mesh.vertices = vertices;
            mesh.triangles = triangles;
            mesh.RecalculateNormals();
            mesh.RecalculateBounds();
            return mesh;
        }

        /// <summary>
        /// Resolve mesh resolution for a given depth to create progressive mesh detail.
        /// Higher depth tiles get exponentially higher resolution meshes to show more geometric detail
        /// of the SAME underlying terrain (height values remain consistent across depths).
        /// </summary>
        private int ResolveResolutionForDepth(int depth)
        {
            if (config != null)
            {
                // Use base resolution from config and scale with depth for more mesh detail
                // This creates progressive geometric detail without changing terrain topology
                int baseRes = config.baseResolution > 0 ? config.baseResolution : 32;

                // Scale resolution with depth to maintain consistent world-space detail density
                // Each depth level doubles the tiles per edge but we want to maintain detail per world unit
                int scaledRes = Mathf.Max(8, baseRes >> depth);

                // Add extra mesh detail for deeper levels (more vertices, same terrain)
                int extraDetail = depth * 16; // Add 16 verts per edge per depth level

                return Mathf.Max(16, scaledRes + extraDetail);
            }

            // Conservative fallback with progressive mesh resolution scaling
            return Mathf.Max(16, 32 + depth * 16);
        }

        /// <summary>
        /// Validate raycast layer configuration to ensure terrain tiles won't occlude themselves.
        /// Call this during setup or from inspector to check configuration.
        /// </summary>
        [ContextMenu("Validate Layer Configuration")]
        private void ValidateLayerConfiguration()
        {
            // Check if terrain tile layer is excluded from raycast mask
            bool isTerrainLayerExcluded = (raycastLayerMask & (1 << terrainTileLayer)) == 0;
            
            if (!isTerrainLayerExcluded)
            {
                // Build a friendly list of included layers from the inspector mask for easier debugging
                var includedLayers = new System.Text.StringBuilder();
                int mask = raycastLayerMask.value;
                for (int i = 0; i < 32; i++)
                {
                    if ((mask & (1 << i)) != 0)
                    {
                        if (includedLayers.Length > 0) includedLayers.Append(", ");
                        includedLayers.Append(LayerMask.LayerToName(i));
                    }
                }

                Debug.LogWarning($"[PlanetTileExplorerCam] Terrain tile layer {terrainTileLayer} is included in raycastLayerMask. " +
                    $"Included layers: {includedLayers}. This may cause terrain tiles to occlude raycasts and prevent proper tile detection. " +
                    "Consider excluding the terrain tile layer from the raycast layer mask.", this);
            }
            else
            {
                    $"Terrain tiles on layer {terrainTileLayer} are excluded from raycast detection.", this);
            }
        }
    }
}
